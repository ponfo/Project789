module CFDStrategyM

  use UtilitiesM
  use SparseKit
  use DebuggerM

  use CFDmodelM
  use CFDApplicationM

  use CFDElementM

  use SolvingStrategyM

  use PrintM

  use CFDSchemeM
  use CFDBuilderAndSolverM
  use SchemeM
  use BuilderAndSolverM

  use NavierStokes2DM

  use RK4M
  use AdamsB4M
  use ExplicitEulerM

  implicit none

  private
  public :: CFDStrategyDT

  type, extends(NewSolvingStrategyDT) :: CFDStrategyDT
   contains
     procedure :: buildStrategyAndSolve
  end type CFDStrategyDT


contains

  subroutine buildStrategyAndSolve(this, app)
    implicit none
    class(CFDStrategyDT)  , intent(inout)    :: this
    type(CFDApplicationDT), intent(inout)    :: app
    type(CFDSchemeDT)                        :: scheme
    type(CFDBuilderAndSolverDT)              :: builderAndSolver
    type(PrintDT)                            :: writeOutput
    type(NavierStokes2DDT)                   :: NavierStokes2D
    type(ExplicitEulerDT)                    :: ExplicitEuler
    type(RK4DT)                              :: RungeKutta4
    type(AdamsB4DT)                          :: AdamsBash4 
    real(rkind), dimension(:,:), allocatable :: oldDof 
    real(rkind), dimension(:)  , allocatable :: auxDof, auxRhs
    real(rkind)                              :: dtMin, dtMin1, t
    real(rkind)                              :: factor, error, porc
    real(rkind)                              :: errorTol, error1(4), error2(4)
    integer(ikind)                           :: maxIter, iNode, nNode, i
    integer(ikind)                           :: step1, step2, printStep
    integer(ikind)                           :: flagg, stab, RK
    logical                                  :: multi_step = .true.
    call debugLog('  *** Transient Strategy ***')
    print'(A)', '*** Transient Strategy ***'
    nNode = app%model%getnNode()
    call allocateLumpedMass(4,nNode)
    call allocateStabMat(nNode)
    allocate(this%scheme, source = SetScheme(scheme))
    allocate(this%builderAndSolver, source = SetBuilderAndSolver(builderAndSolver))
    allocate(this%process, source = WriteOutput)
    allocate(oldDof(4,nNode), auxRhs(nNode*4), auxDof(nNode*4))
    printStep = app%model%processInfo%getPrintStep()
    errorTol  = app%model%processInfo%getErrorTol()
    maxIter   = app%model%processInfo%getMaxIter()
    error     = errorTol+1
    error1    = errorTol+1
    error2    = 1._rkind
    step1     = 0
    step2     = printStep
    t         = 0._rkind
    auxDof    = 0._rkind
    auxRhs    = 0._rkind
    flagg     = 1
    stab      = 1
    RK        = 4
    call calculateMass(app)
    call writeOutput%initPrint()
    do while (step1 .lt. maxIter .and. error .gt. errorTol)
       step1 = step1 + 1
       call calculateDT(app)
       dtMin = app%model%processInfo%getDT()
       if (flagg == 1) then
          dtmin1 = dtmin
          flagg  = 2
       end if
       porc = abs((dtMin-dtMin1)/dtMin)
       if (100._rkind*porc .le. 1._rkind) then
          dtMin = dtMin1
       else
          dtMin1 = dtMin
          flagg  = 2
       end if
       t      = t + dtmin
       oldDof = model%dof
       call app%model%processInfo%setStep(step1)
       if(flagg <= 5) then
          do i = 1, RK
             factor = (1._rkind/(RK+1._rkind-i))
             app%model%rhs = 0._rkind
             if(i == 1) then
                call builderAndSolver%buildAndSolve(app)
             else
                call builderAndSolver%update(app)
             end if
             do iNode = 1, nNode
                auxDof(iNode*4-3:iNode*4) = app%model%dof(:,iNode)
                auxRhs(iNode*4-3:iNode*4) = app%model%rhs(:,iNode)
             end do
             navierStokes2D = SetNavierStokes2D(auxDof, auxRhs, ExplicitEuler, step1)
             call navierStokes2D%integrate(factor*dtMin, multi_step)
             auxDof = navierStokes2D%getState()
             do iNode = 1, nNode
                app%model%dof(:,iNode) = auxDof(iNode*4-3:iNode*4)
             end do
          end do
       else
          if(stab == 4) stab = 1
          app%model%rhs = 0._rkind
          if(stab == 2) then
             call builderAndSolver%buildAndSolve(app)
          else
             call builderAndSolver%update(app)
          end if
          stab = stab + 1
          do iNode = 1, nNode
             auxDof(iNode*4-3:iNode*4) = app%model%dof(:,iNode)
             auxRhs(iNode*4-3:iNode*4) = app%model%rhs(:,iNode)
          end do
          navierStokes2D = SetNavierStokes2D(auxDof, auxRhs, AdamsBash4, step1)
          call navierStokes2D%integrate(dtMin, multi_step)
          auxDof = navierStokes2D%getState()
          do iNode = 1, nNode
             app%model%dof(:,iNode) = auxDof(iNode*4-3:iNode*4)
          end do
       end if
       if (step1 == step2 .or. step1 == maxIter) then
          error1 = 0._rkind
          error2 = 0._rkind 
          do iNode = 1, nNode
             error1(:)  = error1(:) + (app%model%dof(:,iNode)-oldDof(:,iNode))**2
             error2(:)  = error2(:) + oldDof(:,iNode)**2
          end do
          error = maxval(sqrt(error1/error2))
          if (error.gt.1.d2) then
             call debugLog('CONVERGENCE ERROR')
             print'(A)', 'CONVERGENCE ERROR'
             stop
          end if
          call scheme%calculateOutputs(model)
          call writeOutput%print(step1, app%model%results%density           &
               , app%model%results%internalEnergy, app%model%results%mach       &
               , app%model%results%pressure      , app%model%results%temperature&
               , app%model%results%velocity                                )
          call debugLog('::::::::::::::::::::::::::::::::::::::::')
          call debugLog('Step     : ', step1)
          call debugLog('Error Ec. de Continuidad  = ', sqrt(error1(1)/error2(1)))
          call debugLog('Error Ec. de Momento x    = ', sqrt(error1(2)/error2(2)))
          call debugLog('Error Ec. de Momento y    = ', sqrt(error1(3)/error2(3)))
          call debugLog('Error Ec. de Energia      = ', sqrt(error1(4)/error2(4)))
          call debugLog('t        : ', t)
          call debugLog('dt       : ', dtMin)
          call debugLog('Mach Max = ', maxval(app%model%results%mach))
          call debugLog('::::::::::::::::::::::::::::::::::::::::')
          print'(A40)'      , '::::::::::::::::::::::::::::::::::::::::' 
          print'(A11,I10   )', 'Step     : ', step1
          print'(A29,E10.3)', 'Error Ec. de Continuidad  = ', sqrt(error1(1)/error2(1))
          print'(A29,E10.3)', 'Error Ec. de Momento x    = ', sqrt(error1(2)/error2(2))
          print'(A29,E10.3)', 'Error Ec. de Momento y    = ', sqrt(error1(3)/error2(3))
          print'(A29,E10.3)', 'Error Ec. de Energia      = ', sqrt(error1(4)/error2(4))
          print'(A11,E10.3)', 't        : ', t
          print'(A11,E10.3)', 'dt       : ', dtMin
          print'(A11,E10.3)', 'Mach Max = ', maxval(app%model%results%mach)
          print'(A40)'      , '::::::::::::::::::::::::::::::::::::::::' 
          step2 = step2 + printStep
       end if
       flagg = flagg + 1
    end do
    call debugLog('*** Finished Integration ***')
    print'(A)', '*** Finished Integration ***'
  end subroutine buildStrategyAndSolve

  subroutine calculateMass(app)
    implicit none
    type(CFDApplicationDT), intent(inout) :: app
    integer(ikind)                        :: iElem, nElem
    nElem = app%model%getnElement()
    do iElem = 1, nElem
       call app%element(iElem)%calculateMass(localLumpedMass)
    end do
  end subroutine calculateMass

  subroutine calculateDT(app)
    implicit none
    type(CFDApplicationDT), intent(inout) :: app
    nElem = app%model%getnElement()
    do iElem = 1, nElem
       call app%element(iElem)%calculateDT(app%model%processInfo)
    end do
  end subroutine calculateDT
  
end module CFDStrategyM
